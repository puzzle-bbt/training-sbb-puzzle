---
title: "2.2 Git Basics"
linkTitle: "2.2 Git Basics"
weight: 110
sectionnumber: 2.2
---

Git kann auf unterschiedliche Arten eingesetzt werden, es gibt graphische Oberfl√§chen und die meisten Git-Server Software bieten Weboberfl√§chen, welche das interagieren mit Git Repositories kinderleicht gestalten. Da diese Oberfl√§chen meist sehr Produktspezifisch sind und oft auch nicht alle Funktionen beinhaltet werden hier nur die Kommandozeilen Befehle angeschaut.

## Inhalt

* [Konfiguration von Git](#konfiguration-von-git)
* [Hilfe](#hilfe)
* [Ein Git Repository anlegen](#ein-git-repository-anlegen)
* [√Ñnderungen verfolgen und im Repository speichern](#√§nderungen-verfolgen-und-im-repository-speichern)
* [Anzeigen der Commit Historie](#anzeigen-der-commit-historie)
* [√Ñnderungen r√ºckg√§ngig machen](#√§nderungen-r√ºckg√§ngig-machen)
* [Mit Remotes arbeiten](#mit-remotes-arbeiten)

## Konfiguration von Git

Git kann, wie die viele Software unter Linux, auf unterschiedlichen Level konfiguriert werden:

* `/etc/gitconfig` enth√§lt die Werte, welche f√ºr alle Benutzer auf dem System gelten. Die Datei kann mit `git config --system` gelesen oder editiert werden. Man braucht Administrator- oder Superuser-Rechte um die Datei zu editieren.
* `~/.gitconfig` oder `~/.config/git/config` enth√§lt die Werte, welche f√ºr den aktuellen Benutzer konfiguriert sind. Mit `git config --global` k√∂nnen Werte gesetzt oder ausgelesen werden.
* Die Datei `config` im `.git` Verzeichnis innerhalb eines Repositories enth√§lt die Konfiguration, welche nur f√ºr dieses Repository z√§hlt. Das Flag f√ºr `git config` ist in diesem Fall `--local`, ist jedoch in der Regel die Standardoption und kann weggelassen werden.

Jede dieser Konfiguration wird von der n√§chsten √ºberschrieben, sodass die Repository bezogene Konfiguration den h√∂chsten Wert hat. Um zu die aktuelle Konfiguration und ihren Ursprung anzusehen kann folgender Befehl ausgef√ºhrt werden:

```bash
$ git config --list --show-origin
file:/home/lehrling/.gitconfig     user.email=lehrling@puzzle.ch
file:/home/lehrling/.gitconfig     user.name=Lehrling Puzzle
file:/home/lehrling/.gitconfig     push.default=simple
file:/home/lehrling/.gitconfig     merge.tool=meld
file:.git/config        core.repositoryformatversion=0
file:.git/config        core.filemode=true
file:.git/config        core.bare=false
file:.git/config        core.logallrefupdates=true
file:.git/config        remote.origin.url=git@github.com:puzzle-bbt/training-sbb-puzzle.git
file:.git/config        remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*
file:.git/config        branch.master.remote=origin
file:.git/config        branch.master.merge=refs/heads/master
```

### Konfigurationsbeispiele

Nach der Installation von Git sollte als erstes der Name und die Email Adresse konfiguriert werden, da diese beiden Angaben bei jedem Commit ben√∂tigt werden:

```bash
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```

Wie wir bereits gelernt haben, schreiben wir mit dem `--global` Flag in die Konfiguration in unserem `home` Verzeichnis und sie gilt somit f√ºr alle Repositories, welche wir mit unserem User bearbeiten. Wollen wir dies fur ein bestimmtes Repo √ºbersteuern, haben wir immer noch die M√∂glichkeit dies mit `--local` zu machen.

Eine weitere Konfiguration die evtl. hilfreich sein kann ist `core.editor` mit welcher, der Texteditor definiert werden kann. Git benutzt, falls hier nichts definiert ist, den standard Editor des Systems.

## Hilfe

Git bietet mehrere M√∂glichkeit, wie man an Hilfe gelangt, wenn mal einmal nicht weiter weiss:

```bash
$ git help <verb>
$ git <verb> --help
$ man git-<verb>
# Kurzversion:
$ git <verb> -h
```

Wenn man also nicht mehr genau weiss, wie dies mit der Konfiguration von Git funktioniert kann man sich folgendermassen weiterhelfen:

```bash
$ git help config #ruft die Manpage auf
[..]
$ git config -h
usage: git config [<options>]

Config file location
    --global              use global config file
    --system              use system config file
    --local               use repository config file
    --worktree            use per-worktree config file
    -f, --file <file>     use given config file
    --blob <blob-id>      read config from given blob object

Action
    --get                 get value: name [value-regex]
    --get-all             get all values: key [value-regex]
    --get-regexp          get values for regexp: name-regex [value-regex]
    --get-urlmatch        get value specific for the URL: section[.var] URL
    --replace-all         replace all matching variables: name value [value_regex]
    --add                 add a new variable: name value
    --unset               remove a variable: name [value-regex]
    --unset-all           remove all matches: name [value-regex]
    --rename-section      rename section: old-name new-name
    --remove-section      remove a section: name
    -l, --list            list all
    -e, --edit            open an editor
    --get-color           find the color configured: slot [default]
    --get-colorbool       find the color setting: slot [stdout-is-tty]

Type
    -t, --type <>         value is given this type
    --bool                value is "true" or "false"
    --int                 value is decimal number
    --bool-or-int         value is --bool or --int
    --path                value is a path (file or directory name)
    --expiry-date         value is an expiry date

Other
    -z, --null            terminate values with NUL byte
    --name-only           show variable names only
    --includes            respect include directives on lookup
    --show-origin         show origin of config (file, standard input, blob, command line)
    --show-scope          show scope of config (worktree, local, global, system, command)
    --default <value>     with --get, use default value when missing entry
```

## Ein Git Repository anlegen

Um lokal ein neues Git Repository anzulegen gibt es zwei Varianten:

* Umwandeln eines Verzeichnis, welches (noch) nicht mit Git verwaltet wird zu einem Git Repository
* Klonen eines existierenden Repositories von einem anderen Ort

### Ein Verzeichnis zu einem Git Repository verwandeln

Um aus einem Ordner ein Git Repository zu erstellen, muss man zuerst in den Ordner wechseln und anschliessend das Repository initialisieren:

```bash
$ cd ~/path/to/folder
$ git init
```

Der zweite Befehl erzeugt ein `.git` Unterverzeichnis, welches die Repository Daten beinhaltet. Im Moment werden noch keine Dateien von Git verwaltet, sondern die m√ºssen zuerst hinzugef√ºgt (`git add`) werden und committed werden (`git commit`). Wenn wir von einem leeren Ordner aus gehen, m√ºssen die Dateien nat√ºrlich zuerst noch erstellt werden:

```bash
$ vim README.md
$ git add README.md
$ git commit -m 'Initial Commit'
```

### Ein bestehendes Repository klonen

Um ein Repository zu klonen wird der Befehl `git clone` verwendet:

```bash
$ git clone https://github.com/libgit2/libgit2
$ ls
libgit2
```

Git legt dann automatisch ein Verzeichnis `libgit2` an mit allen Dateien und initialisiert das Repository mit einem `.git` Verzeichnis im Hauptverzeichnis. Wird hinter der URL noch etwas angegeben, wird dies als Name des Zielverzeichnisses interpretiert:

```bash
$ git clone https://github.com/libgit2/libgit2 mylibgit
$ ls
mylibgit
```

## √Ñnderungen verfolgen und im Repository speichern

Zur Erinnerung, eine Datei in einem Git Folder kann vier Zust√§nde haben:

* Untracked: Die Datei liegt im Ordner, wird aber nicht von Git versioniert
* Unmodified: Die Datei wird von Git versioniert, sie ist seit dem letzten Commit unver√§ndert.
* Modified: Die Datei wurde seit dem letzten Commit ver√§ndert
* Staged: eine neue oder editierte Datei wurde f√ºr den n√§chsten Commit vorgemerkt.

Der Befehl zum √ºberpr√ºfen, ob man Dateien in einem anderen Zustand als `unmodified` hat ist `git status`:

```bash
$  git status
On branch feature/git-basics
Your branch is up to date with 'origin/feature/git-basics'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   content/en/docs/02.0/02.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   content/en/docs/02.0/02.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	.gitignore
```

Wollen wir nun die √Ñnderungen der Datei `content/en/docs/02.0/02.md` (oder die Datei `.gitignore`) zum n√§chsten Commit hinzuf√ºgen k√∂nnen wir dies mit `git add <pfad/zur/datei>`. Im Beispiel oben sehen wir, dass die Datei `content/en/docs/02.0/02.md` bereits gestaged ist. √Ñndern wir diese Datei erneut, wird die Datei sowohl bei *Changes to be committed:* wie auch bei *Changes not staged for commit:* auftauchen. Einmal mit den √Ñnderungen, welche wir bereits gestaged haben und einmal mit den √Ñnderungen, welche wir nach dem Stagen (`git add`) gemacht haben. Wollen wir beide √Ñnderungen im gleichen Commit, k√∂nnen wir die Datei einfach wieder mit `git add` stagen und anschliessend commiten, wollen wir die √Ñnderungen in separaten Commit, commiten wir zuerst die gestagten √Ñnderungen und stagen anschliessend die zweite √Ñnderungen und commiten erneut.

### .gitignore

Bevor wir lernen, wie man seine √Ñnderungen commited wollen wir noch kurz die spezielle Datei `.gitignore` anschauen. In dieser Datei k√∂nnen Dateien erfasst werden, welche Git nicht als untracked aufz√§hlen soll, respektive ignorieren soll. Die Datei wird ganz normal wie jede andere auch ins Repo eingecheckt.

```bash
$ cat .gitignore
# ignore all .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in any directory named build
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory and any of its subdirectories
doc/**/*.pdf
```

Weitere Informationen bekommt man mit `man gitignore` oder unter https://github.com/github/gitignore findet man n√ºtzliche Beispiele.

### √úberpr√ºfen der √Ñnderungen

Bevor man seine √Ñnderungen commited, empfiehlt es sich diese nochmals zu √ºberpr√ºfen. Mit `git status` sieht man, welche Dateien ge√§ndert wurden, jedoch nicht, was sich ge√§ndert hat. Daf√ºr gibt es den Befehl `git diff`:

```diff
diff --git a/content/en/docs/02.0/02.md b/content/en/docs/02.0/02.md
index 1e6db46..dd7161b 100644
--- a/content/en/docs/02.0/02.md
+++ b/content/en/docs/02.0/02.md
@@ -145,3 +145,60 @@ mylibgit

 ## √Ñnderungen verfolgen und im Repository speichern

+Zur Erinnerung, eine Datei in einem Git Folder kann vier Zust√§nde haben:
-Zur Erinnerung, eine Datei in einem Git Folder kann vier Zustaende haben
```

`git diff` vergleicht die √Ñnderungen welche noch nicht gestaged wurden, will man bereits gestagte √Ñnderungen √ºberpr√ºfen braucht es zus√§tzlich das Flag `--staged` oder `--cached` (die beiden Flags sind Synonyme).

### Commiten

Ist man sicher, dass man nur die √Ñnderungen gestaged hat, welche man auch commiten will, kann man dies mit dem Befehl `git commit` bewerkstelligen. Dadurch wird ein Editor ge√∂ffnet und man wird gebeten eine Beschreibung f√ºr die √Ñnderungen anzugeben. Wie solche Beschreibungen gestaltet werden sollen und was alles in eine "Commit Message" geh√∂rt, dar√ºber gibt es ganz unterschiedliche Meinungen. Idealerweise probiert man sich vorzustellen, was man an Zus√§tzlichen Informationen braucht, wenn man die √Ñnderungen in zwei Jahren wieder anschaut, um zu verstehen, was und warum das ge√§ndert wurde.

Ein paar hilfreiche Flags zu `git commit`:

* `-m` um eine Message gleich anzugeben und nicht den Editor zu √∂ffnen (kann je nach Commit Message Guideline hinderlich sein, da es keine Multiline Kommentare erlaubt):

```bash
git commit -m "Story 182: added important Information to Readme"
[master 463dc4f] Story 182: added important Information to Readme
 2 files changed, 2 insertions(+)
 create mode 100644 README
 ```

* `-a` um alle editierten Dateien gleich mitzustagen. (Kurzform von `git add --all && git commit`) **!ACHTUNG!** kann gef√§hrlich sein da so schnell √Ñnderungen in einen Commit rutschen die nicht rein geh√∂ren!

* `-v` um ein `git diff --staged` im Editor angezeigt zu bekommen. So muss man sich nicht merken, was man eigentlich ge√§ndert hat und bekommt es beim schreiben der Commit Message noch einmal pr√§sentiert.

**WICHTIG:** Es ist einiges einfacher Fehler vor dem Commiten als nach dem Commiten zu beheben, ein zweites mal √ºber die √Ñnderungen schauen ist sehr empfehlenswert!

### Dateien l√∂schen

Um eine Datei zu l√∂schen muss diese zuerst entfernt und dann gestaged werden, damit dies in der Git Datenbank ankommt. Um nicht zuerst `rm foo` und dann `git add foo` eingeben zu m√ºssen, gibt es den Befehl `git rm foo`. Will man eine bereits gestagte Datei aus der Versionsverwaltung jedoch nicht vom Filesystem l√∂schen, weil man diese zum Beispiel im `.gitignore` erg√§nzen m√∂chte, dann kann man dies mit `git rm --cached foo` erledigen.

**WICHTIG:** Jede Datei die irgendwann mal commited wurde ist f√ºr immer in der Git Geschichte und kann nur durch neu schreiben der selbigen wieder entfernt werden. Wer also zum Beispiel sein Passwort commited weil dies in einer `secret.yml` Datei steht, der sollte sich sofort bei einem 10x-Git-Profi-Engineer Hilfe holen.

### Dateien Verschieben

Genauso wie l√∂schen, muss auch beim Verschieben die √Ñnderung Git mitgeteilt werden: `mv README.md README &&  git rm README.md && git add README` oder in kurz und h√ºbsch: `git mv README.md README`.

## Anzeigen der Commit Historie

Um die Geschichte eines Git Repositories anzuzeigen gibt es den Befehl `git log`. Ohne Argumente zeigt `git log` die Commits in umgekehrter chronologischer Reihenfolge, sprich j√ºngster Commit zuoberst. Pro Commit wird jeweils der Commit-Hash, der Name und Email Adresse des Authors, das Datum und die Commit-Message angezeigt. Um die effektiven √Ñnderungen anzuzeigen gibt es das `-p` oder `--patch` Flag verwendet werden. Da der Output schnell gross wird und man wahrscheinlich auch nicht bis an den Ursprung der Geschichte zur√ºck will empfiehlt es sich die Anzahl Commits anzugeben, will man zum Beispiel die letzten drei Commits anschauen macht man dies mit `-3`. Oder man schr√§nkt die √Ñnderungen basierend auf die Zeit ein mit `--since=` und `--until=` ein (es werden die unterschiedlichsten Zeitangaben akzeptiert, am besten probiert man etwas aus. Bsp: `--since=2.weeks` oder `--until="2020-06-03"`). Auch mit `--grep` oder `--author` kann man die Resultate einschr√§nken. Weitere Information liefert die Manpage `man git log` und die Hilfefunktion `git log -h`.

## √Ñnderungen r√ºckg√§ngig machen

Wo gehobelt wird fallen Sp√§ne. Die meisten Schnitzer kann man jedoch selber wieder ausgl√§tten. Am h√§ufigsten committed man wohl zu schnell, hat eine Datei vergessen dazuzuf√ºgen oder hat sich bei der Commit Message vertan. Hier kann man ganz einfach die √Ñnderungen noch vornehmen und an den letzten Commit berichtigen mit `git commit --amend` (Wichtig, man editiert nicht den letzten Commit, sondern man l√∂scht ihn und erstellt eine korrigierte neue Version davon. Dies kann dazuf√ºhren, dass ein Remote den Commit nicht mehr annimmt, da die History nicht mehr √ºbereinstimmt. Aber mehr dazu sp√§ter.)

Um eine gestagte Datei wieder zu modified (aber eben nicht gestaged) zu verschieben kann man `git reset HEAD <file>` verwenden. Um die √Ñnderungen einer Datei r√ºckg√§ngig zu machen (also modified zu unmodified)
kann sie neu ausgecheckt werden mit `git checkout -- <file>`. **Achtung** Alle √Ñnderungen seit dem letzte Commit gehen damit verloren!!! Wenn man sich an die beiden Befehle gerade mal nicht erinnern kann, dann kann man einfach ein `git status` eingeben und den Hilfetext studieren üòâ.

## Mit Remotes arbeiten

Um mit anderen an einem Git-Projekt mitarbeiten zu k√∂nnen, braucht es Remotes, sprich eine Version des Projekts im Netzwerk, wo alle Beteiligten ihre √Ñnderungen hin pushen und die √Ñnderungen der Anderen pullen k√∂nnen.

Nachdem man ein Repo gecloned hat sieht man ein Remote, man kann jedoch auch weitere definieren:

```bash
$ git clone git@github.com:puzzle-bbt/training-sbb-puzzle.git
Cloning into 'training-sbb-puzzle'...
remote: Enumerating objects: 8485, done.
remote: Counting objects: 100% (8485/8485), done.
remote: Compressing objects: 100% (5276/5276), done.
remote: Total 8485 (delta 3095), reused 8456 (delta 3079), pack-reused 0
Receiving objects: 100% (8485/8485), 17.06 MiB | 5.11 MiB/s, done.
Resolving deltas: 100% (3095/3095), done.
$ cd training-sbb-puzzle
$ git remote
origin
$ git remote -v
origin	git@github.com:puzzle-bbt/training-sbb-puzzle.git (fetch)
origin	git@github.com:puzzle-bbt/training-sbb-puzzle.git (push)
$ git remote add private git remote add private git@github.com:Lehrling/training-sbb-puzzle.git
$ git remote -v
origin	git@github.com:puzzle-bbt/training-sbb-puzzle.git (fetch)
origin	git@github.com:puzzle-bbt/training-sbb-puzzle.git (push)
private	git@github.com:Lehrling/training-sbb-puzzle.git (fetch)
private	git@github.com:Lehrling/training-sbb-puzzle.git (push)
```

Wollen wir nun alle Information holen, welches der Lehrling hat, jedoch noch nicht im Repo sind kann man dies mit `git fetch private` ausf√ºhren.

### Fetching und Pulling

Es gibt zwei Arten, wie man Daten von einem Remote abholen kann, nach dem man das Repo gecloned hat.

- `git fetch <remote>`: holt alle √Ñnderungen vom Remote seit dem letzten abholen und speichert die lokal. Wichtig zu beachten ist, dass `git fetch` die √Ñnderungen nicht mit den lokalen √Ñnderungen zusammenf√ºgt, sondern dies manuell ausgef√ºhrt werden muss.

- `git pull`: Wenn der lokale Branch mit einem remote Branch verkn√ºpft ist, holt `git pull` die √Ñnderungen dieses remotes und f√ºgt sie gleich mit den √Ñnderungen im lokalen Branch zusammen (merge). Was Branches sind und wie ein Merge funktioniert schauen wir uns in k√ºrze an, nur soviel, wird ein Repo gecloned, wird der lokale sogenannte `master` Branch mit dem `master` Branch des `origin` Remotes verkn√ºpft.

### Pushen

Wenn man seine √Ñnderungen soweit hat, dass man sie mit dem Rest vom Team teilen will, dann kann man diese mit `git push <remote> <branch>` auf den Server laden. Dies funktioniert jedoch nur, wenn man auf dem Server auch Schreibrechte hat und niemand anderes vor einem gepusht hat.
